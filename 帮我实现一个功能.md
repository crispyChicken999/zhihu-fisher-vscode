# 知乎渔夫 - 文章/问题切换功能需求文档

## 功能概述
实现在webview中通过键盘快捷键快速切换同一来源列表中的上一篇/下一篇文章或问题的功能。

## 现状分析
- ✅ 已实现：左右键切换同一问题下的不同回答
- ❌ 待实现：切换不同问题/文章的功能
- ⚠️ **问题发现**：当前 `WebViewItem` 类型定义中缺少 `sourceType` 字段，需要先修复

## 功能需求

### 1. 基本功能
- 用户在webview中按 `Ctrl + ↑/↓` 键可以切换上/下篇文章或问题
- 支持四种来源类型的切换：
  - 推荐列表 (recommend)
  - 热榜列表 (hot) 
  - 搜索结果 (search)
  - 收藏夹内容 (collection)

### 2. 切换逻辑
当用户触发切换操作时：
1. 根据当前webview的 `sourceType` 确定数据来源
2. 在对应的列表中查找当前项的位置
3. 获取上一项或下一项的数据
4. 创建新的webview显示目标内容

### 3. 边界处理
- 如果已是第一项，按 `Ctrl + ↑` 应提示"已经是第一篇了"
- 如果已是最后一项，按 `Ctrl + ↓` 应提示"已经是最后一篇了"
- 如果在列表中找不到当前项（用户可能刷新了列表），提示"未找到上/下篇内容，请刷新列表后重试"

### 4. 状态管理
- 保留当前webview的状态，用户可能切换回来
- 新创建的webview应该独立管理自己的状态
- 切换过程中应中断当前正在进行的加载更多回答操作

### 5. 用户体验
- 使用 `Ctrl + 上/下键` 避免与页面滚动快捷键冲突
- 提供清晰的状态提示
- 切换过程要流畅，避免卡顿

## 技术实现要点

### 1. 🚨 必须先修复的问题
**当前 `WebViewItem` 类型定义缺少 `sourceType` 字段**

需要在 `src/core/types/index.ts` 中修改 `WebViewItem` 接口：
```typescript
export interface WebViewItem {
  /** 问题ID  */
  id: string;
  /** 问题对应的URL */
  url: string;
  /** 问题的内容数据 */
  article: ArticleInfo;
  /** vscode的视图面板 */
  webviewPanel: vscode.WebviewPanel;
  /** 是否正在加载 */
  isLoading: boolean;
  /** 是否已加载 */
  isLoaded: boolean;
  /** 来源类型 - 新增字段 */
  sourceType: "collection" | "recommend" | "hot" | "search";
  /** 原始链接项数据 - 新增字段，用于查找列表位置 */
  originalItem: LinkItem;
  /** BatchConfig 批次加载的参数，方便终止递归 */
  batchConfig: {
    /** 加载前的回答数量 */
    beforeLoadCount: number;
    /** 加载后的回答数量 */
    afterLoadCount: number;
    /** 每一批次加载的数量限制 */
    limitPerBatch: number;
    /** 正在加载批次，避免重复加载 */
    isLoadingBatch: boolean;
  };
}
```

### 2. 数据来源识别
```typescript
// 各个列表的数据存储位置
Store.Zhihu.hot.list          // 热榜列表
Store.Zhihu.recommend.list    // 推荐列表  
Store.Zhihu.search.list       // 搜索结果
Store.Zhihu.collections.*     // 收藏夹内容（需要具体分析结构）
```

### 3. 键盘事件处理
在 `templates/scripts.ts` 中的 `setupKeyboardNavigation()` 函数中添加：
```typescript
// Ctrl + 上箭头 - 上一篇文章/问题
if (event.ctrlKey && event.key === 'ArrowUp') {
  vscode.postMessage({ command: "loadPreviousArticle" });
  event.preventDefault();
}

// Ctrl + 下箭头 - 下一篇文章/问题  
if (event.ctrlKey && event.key === 'ArrowDown') {
  vscode.postMessage({ command: "loadNextArticle" });
  event.preventDefault();
}
```

### 4. 中断机制
检查当前是否有正在进行的加载操作：
```typescript
// 检查是否正在加载
if (webviewItem.batchConfig.isLoadingBatch || webviewItem.isLoading) {
  // 中断加载操作
  webviewItem.batchConfig.isLoadingBatch = false;
  webviewItem.isLoading = false;
}
```

### 5. Webview管理
- 为新创建的webview生成唯一ID
- 保持原有webview的状态（不关闭）
- 考虑内存管理，避免创建过多webview

## 实现步骤

### 第零步：修复数据结构 🚨
1. 修改 `src/core/types/index.ts` 中的 `WebViewItem` 接口，添加 `sourceType` 和 `originalItem` 字段
2. 修改 `src/core/zhihu/webview/index.ts` 中的 `openWebview` 方法，在创建 `webviewItem` 时保存这些信息

### 第一步：扩展键盘事件处理
在 `src/core/zhihu/webview/templates/scripts.ts` 中添加新的键盘事件

### 第二步：添加切换命令处理
在 `src/core/zhihu/webview/index.ts` 的 `setupMessageHandling` 方法中添加：
- `loadPreviousArticle` 
- `loadNextArticle`

### 第三步：实现切换逻辑
创建新的方法：
- `loadPreviousArticle(webviewId: string)`
- `loadNextArticle(webviewId: string)`  
- `findItemIndexInList(item: LinkItem, list: LinkItem[]): number`
- `getListBySourceType(sourceType: string): LinkItem[]`

### 第四步：完善状态管理
- 确保切换过程中的loading状态正确处理
- 实现中断机制

### 第五步：用户提示
实现各种边界情况的用户提示

## 收藏夹数据结构分析

通过代码分析发现，收藏夹的数据结构比较复杂：

### 主要数据结构
```typescript
Store.Zhihu.collections: {
  myCollections: CollectionFolder[];        // 我创建的收藏夹列表
  followingCollections: CollectionFolder[]; // 我关注的收藏夹列表
  userInfo: ZhihuUser | null;              // 当前用户信息
  // 分页信息等...
}

interface CollectionFolder {
  id: string;                    // 收藏夹ID
  title: string;                 // 收藏夹标题
  url: string;                   // 收藏夹URL
  items: CollectionItem[];       // 收藏夹内的具体内容
  type: "created" | "following"; // 收藏夹类型
  totalCount?: number;           // 总数量
  // 其他字段...
}

interface CollectionItem {
  id: string;                           // 收藏项ID
  type: "answer" | "article" | "question"; // 内容类型
  url: string;                          // 内容URL
  title: string;                        // 标题
  excerpt: string;                      // 摘要
  // 其他字段...
}
```

### 收藏夹切换的特殊处理

**关键发现**：收藏夹与其他列表的数据结构不同，需要特殊的查找逻辑：

1. **数据层次**：收藏夹是二级结构（收藏夹 → 收藏项），而其他列表是一级结构
2. **查找方式**：需要遍历所有收藏夹，在每个收藏夹的 `items` 数组中查找
3. **转换处理**：需要将 `CollectionItem` 转换为 `LinkItem` 格式

### 实现方案

```typescript
// 收藏夹切换需要的辅助函数
function findCollectionItemInAllCollections(targetItem: LinkItem): {
  collectionFolder: CollectionFolder;
  itemIndex: number;
} | null {
  const allCollections = [
    ...Store.Zhihu.collections.myCollections,
    ...Store.Zhihu.collections.followingCollections
  ];
  
  for (const collection of allCollections) {
    const itemIndex = collection.items.findIndex(item => 
      item.id === targetItem.id && item.type === targetItem.type
    );
    
    if (itemIndex !== -1) {
      return { collectionFolder: collection, itemIndex };
    }
  }
  
  return null;
}

function convertCollectionItemToLinkItem(item: CollectionItem): LinkItem {
  return {
    id: `collection-${item.id}`,
    url: item.url,
    title: item.title,
    excerpt: item.excerpt,
    type: item.type === "answer" ? "question" : item.type as "question" | "article",
    imgUrl: item.thumbnail,
    // 对于回答类型，需要特殊处理
    answerUrl: item.type === "answer" ? item.url : undefined
  };
}
```

### 注意事项

1. **ID前缀处理**：收藏夹项的ID通常带有 `collection-` 前缀，需要正确处理
2. **回答类型特殊处理**：收藏的回答需要转换为对应的问题页面
3. **懒加载**：收藏夹内容是懒加载的，可能需要先触发加载
4. **权限问题**：某些收藏夹可能有访问权限限制

## 注意事项

1. **数据结构修复优先级最高**：必须先添加 `sourceType` 字段
2. **性能考虑**：避免创建过多webview实例，考虑设置最大数量限制
3. **内存管理**：及时清理不再需要的webview和浏览器页面
4. **错误处理**：网络异常、数据不存在等情况的优雅处理
5. **用户体验**：切换应该快速响应，避免长时间等待
6. **一致性**：保持与现有功能的交互模式一致
7. **收藏夹特殊处理**：收藏夹的数据结构可能需要特殊的查找逻辑

## 测试场景

1. **基础功能测试**：
   - 在推荐列表中打开文章，测试切换到上/下篇
   - 在热榜中打开问题，测试切换功能
   - 在搜索结果中测试切换
   - 在收藏夹中测试切换

2. **边界情况测试**：
   - 测试第一篇、最后一篇的处理
   - 测试列表刷新后的处理
   - 测试网络异常情况

3. **状态管理测试**：
   - 测试切换过程中的中断机制
   - 测试多个webview同时存在的情况
   - 测试内存使用情况

4. **用户体验测试**：
   - 测试快捷键的响应速度
   - 测试提示消息的准确性
   - 测试与现有功能的兼容性

## 代码审查要点

在实现过程中需要特别注意：

1. **类型安全**：确保所有新增字段都有正确的类型定义
2. **向后兼容**：确保修改不会破坏现有功能
3. **错误处理**：每个步骤都要有适当的错误处理
4. **性能优化**：避免不必要的重复计算和内存泄漏
5. **代码一致性**：保持与现有代码风格的一致性